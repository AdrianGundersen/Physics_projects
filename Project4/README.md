# Project 4

## Description
Simulation of the 2D Ising model using the Metropolis algorithm.

## Physical Model
We consider a 2D square \(L\times L\) lattice of spins \(s_i = \pm 1\) with periodic boundary conditions and without an external magnetic field. The total energy of the system is given by:
$$
E = -J \sum_{\langle i,j \rangle}^N s_i s_j, \qquad J>0,\; N = L^2
$$
where the sum runs over all nearest-neighbor pairs \(\langle i,j \rangle\). The magnetization is defined as:
$$
M = \sum_{i=1}^N s_i
$$

We will use this to study phase transitions in the system as we vary the temperature \(T\). 

## Project Structure
```text
Project4/
├── Makefile                 # Build targets (consider switching to CMake if desired)
├── README.md                # Project overview and quickstart
├── PROJECT_PLAN.md          # Internal project plan (scope, timeline, tasks)
├── configs/                 # JSON configs for different runs
│   └── ...
├── data/                    # Numerical outputs, logs, tables
│   └── auto-generated data files
├── figs/                    # Plots and figures generated from results
│   └── (auto-generated images)
├── include/                 # Header files
│   ├── ising/
│   │   ├── io/
│   │   │   ├── json_util.hpp # JSON helper functions.
│   │   │   └── write_files.hpp 
│   │   ├── lattice.hpp 
│   │   └── metropolis.hpp
│   └── 
├── src/                     # Implementation files
│   ├── ising/
│   |   ├── io/
│   |   │   └── write_files.cpp
│   |   ├── lattice.cpp
│   |   ├── metropolis.cpp
│   |   ├── model.cpp
│   |    ├── observables.cpp
│   └── omp_rng.cpp
├── apps/                    # Executables running JSON configs
│   ├── Ln.cpp               # Main application for lattice size Ln
│   ├── runtime.cpp          # Compare runtime of parallel vs serial
│   └── validate2x2.cpp      # Validate against analytical 2x2 solution
└── Plotting/                # Plotting scripts (Python)
    ├── L20.py               # Plots results for L = 20 lattice
    ├── plot_cv_chi.py       # Plots T vs Cv and Chi and marks Tc
    ├── 2x2.py               # Plots 2x2 validation results
    └── runtime.py           # Compares runtime of parallel vs serial
    
```

## Installation and Dependencies


- **C++20 compiler** (e.g. g++ 11 or higher)
- **Armadillo** 
- **OpenMP** 
- **Python 3.10+**
- **nhlomann/json** (header-only C++ JSON library) - included in    `include/` folder
  - `numpy`
  - `matplotlib`


### Ubuntu/Debian
```bash
sudo apt update
sudo apt install g++ make libarmadillo-dev python3 python3-pip
pip3 install numpy matplotlib
```

Other systems not tested, but should work with similar steps.


## Usage & Compilation
To see how make targets are defined, check the `Makefile` or run:
```bash
make help
```

### Using JSON config files
The executables in the `apps/` folder read parameters from JSON config files located in the `configs/` folder. You can create your own config files by copying and modifying the existing templates. The argument `use_Trange` tells the program to run for a single temeprature of not. 

**Example**
```json
{
    "model": // Model parameters
    {
        "J": 1.0, // Interaction strength
        "double_count" : false, // Whether to double count energy
        "spin_config": "all_up" // Initial spin configuration: "all_up", "all_down", "random"
    },
    "lattice": // Lattice parameters
    {
        "L" : 2 // Lattice size (LxL)
    },
    "simulation": // Simulation parameters (Metropolis)
    {
        "seed": 67, // Mother seed for random number generator
        "temperature": 2.0, // Temperature [J/kB], using this temperature if "use_Trange": false
        "use_Trange": true, // Bool too run over multiple temeratures (makes temperature parameter obsolete)
        "Trange": {
            "Tmin": 2.1,    // Starting temerature
            "Tmax": 2.4,    // End temeprature
            "Tsteps": 11    // Number of temerature steps from Tmin to Tmax
        },
        "total_steps": "N", // Total Monte Carlo steps ("N" means number af spins but can also be any integer)
        "measure_sweeps": 10, // Measure observables every n sweeps
        "total_sweeps": 3000, // Total number of sweeps after burn-in
        "cores": 4, // Number of CPU cores to use
        "walkers": 4, // Number of independent walkers (should be = n * cores for best performance)
        "qr": false // Bool to write lattice spins to file, only works if "use_Trange": false.
    },
    "write_to_file": 
    {
        "enabled": true, // whether to write results to file
        "observables": ["e", "m"], // what observables to write [e, m] for txt [cv, chi] for json
        "type": "txt", // file type: "txt", "json" (only txt & json supported currently)
        "delimiter": ",", // delimiter for txt files
        "precision": 6, // number of decimal places
        "output_filename": "default", // output filename (if "default", uses autogenerated name)
        "header": false, // only for txt
        "average_or_concatenate": "concatenate" // average takes average over all wakers, concatenate merges all data from walkers into one file (average NEVER recommended as it loses info, but was used for testing purposes)
    }
}
```

**Caveats**
- For writing to json:
  - Only T_range mode is supported. 
  - Will not care about "observables" field. Always writes (Cv, chi, avg_eps, avg_mabs, avg_eps2, avg_mabs2, avg_eps3, avg_mabs3, avg_eps4, avg_mabs4).

- For writing to txt:
    - T_range mode not supported.
    - Only eps and m supported. Gives energy and magnetization per spin.
    - Recommended to use only one walker for ordered data.

### Compile
To compile the code to `bin/`, use:
```bash
make all
```

or to compile only specific:
```bash
make <target>
```

### Run
To run the code locally, use:
```bash 
make run-2x2 JSON=configs/2x2_test.json
```


**Raspberry Pi**
We have also used a raspberry pi 5 for extra computational power. To run raspberry pi, use:
```bash
make PI_HOST=<your_pi_host>
```

or set the `PI_HOST` variable in the `Makefile` and run:
```bash
make run-pi
```
Depending on your version and OS, you might need to change `PI_ARCH` variable in the `Makefile` to match your architecture.


### Plotting

### What different scripts do:
- `L20.py`: Plots results for lattice size L =20. Mainly used to look at burn-in.
- `plot_cv_chi.py`: Plots specific heat capacity and magnetic susceptibility vs temperature for different lattice sizes, marking the critical temperature.
- `runtime.py`: Compares runtime of parallel vs serial implementation of Metropolis algorithm.


## Future work
- Generalize Metropolis for any model.
- Make a better write_to_file script that can have more options and raises errors when unsupported options are chosen. Also structure it into multiple functions for better readability.

## Declaration of Use of Generative AI

In this scientific work, generative artificial intelligence (AI) has been used. All data and personal information have been processed in accordance with the University of Oslo’s regulations, and we, as the authors of the document, take full responsibility for its content, claims, and references. An overview of the use of generative AI is provided below.

**Summary**

- **Tool(s) used:** [OpenAI ChatGPT (GPT-5)](https://chatgpt.com/)
- **Use:**
  - Generating boilerplate code (e.g., plotting with `matplotlib`).
  - Generating Makefiles.
  - Formatting `README.md`.
  - Checking language for clarity and grammar; general proofreading.
  - Generating brief code documentation, comments, and variable names to improve readability and adhere to conventions.
  - Creating tables in proper TeX format.
  - Brainstorming ideas for code optimization and efficiency.